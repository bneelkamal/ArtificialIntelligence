# Optimal Meetup Location Search

This project tackles a pathfinding problem to determine the best meeting district for two friends traveling from **Pune, Maharashtra** and **Bangalore, Karnataka**. The solution models India's districts as a graph and compares the performance of **Greedy Best-First Search (GBFS)** and **A*** search algorithms. Each algorithm is tested with two distinct heuristics to find the meeting point that minimizes the simultaneous travel time for both friends.

## 1. Methodology
The problem is modeled as a graph search where a "state" is the pair of current locations for both friends. The search aims to find a goal state where both friends are in the same district.

### Graph Construction
The map of India is represented as a graph where:
*   **Nodes**: Districts of India, identified by a `(district, state)` tuple to handle duplicate names.
*   **Edges**: Connect geographically adjacent districts. Adjacency is determined using a **spatial join**.
*   **Weights**: Represent travel time, estimated as `2 * Haversine distance` between the **centroids** of connected districts.

> **Spatial Join:** A technique in GIS that combines datasets based on spatial relationships. I used `geopandas.sjoin` with the `"touches"` predicate to identify neighbouring districts that share a boundary. This established the connections (edges) in the graph, ensuring geographic accuracy.
>
> **Centroid Usage:** The geometric center of a district’s shape. By reducing complex district polygons to single centroid points, I enabled straightforward distance calculations using the Haversine formula, which was critical for estimating travel times efficiently.

### Search Algorithms and Heuristics
I implemented two search algorithms (GBFS and A*) and two heuristics to guide them.

> **Main Heuristic:** For a state (A, B), this heuristic finds the minimum possible time until they meet. It considers all possible meeting points M and calculates the maximum travel time from A to M or B to M (since both friends travel at the same time), then takes the smallest of these values. It uses pre-computed shortest paths (via Dijkstra's algorithm) for accuracy.
>
> **Euclidean Heuristic:** A simpler estimate based on the straight-line (Haversine) distance between the friends’ current districts. It’s quick to compute but less accurate as it doesn’t account for the actual road network.

## 2. How to Run the Search

The project requires several geospatial and data science libraries.

**Dependencies:**

pip install geopandas folium pandas numpy haversine

*Note: `geopandas` may require additional system libraries like GDAL.*

**Execution:**

The script will run all four search strategy combinations, print the results to the console, and generate interactive `Folium` maps (`.html` files) visualizing the paths for each strategy.

## 3. Findings and Results

The performance of each algorithm and heuristic combination was measured. A* search consistently found the optimal path, while the choice of heuristic greatly impacted efficiency.

| Algorithm & Heuristic | 
|:--- |
| A* with **Main Heuristic** |
| GBFS with Main Heuristic |
| A* with Euclidean Heuristic |
| GBFS with Euclidean Heuristic |

**Observations:**
*   **Path Quality**: A* found the optimal meeting point (Haveri) with a lower total cost than the suboptimal paths found by GBFS.
*   **Heuristic Impact**: The main heuristic was far more effective at guiding the search, resulting in significantly fewer nodes being explored and faster execution times compared to the less-informed Euclidean heuristic.

The interactive `Folium` maps generated by the script provide a clear visualization of the different paths taken by the friends for each strategy.
